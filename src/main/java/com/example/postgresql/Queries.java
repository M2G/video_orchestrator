// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
//   sqlc-gen-java 0.0.7

package com.example.postgresql;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.jspecify.annotations.NonNull;

@Generated("io.github.tandemdude.sqlc-gen-java")
public class Queries {
    private final java.sql.Connection conn;

    public Queries(java.sql.Connection conn) {
        this.conn = conn;
    }


    private static final String cleanupStuckJobs = """
        -- name: CleanupStuckJobs :exec
        UPDATE video_jobs
        SET status = 'FAILED',
            updated_at = now()
        WHERE status = 'PROCESSING'
          AND updated_at < now() - interval '30 minutes'
        """;

    public void cleanupStuckJobs() throws SQLException {
        var stmt = conn.prepareStatement(cleanupStuckJobs);

        stmt.execute();
    }

    private static final String lockAndMarkProcessing = """
        -- name: LockAndMarkProcessing :many
        WITH jobs AS (
            SELECT id
            FROM video_jobs
            WHERE status = 'PENDING'
            ORDER BY created_at
            LIMIT ?
            FOR UPDATE SKIP LOCKED
                    )
        UPDATE video_jobs
        SET status = 'PROCESSING',
            updated_at = now()
        WHERE id IN (SELECT id FROM jobs)
            RETURNING id, filename, retry_count
        """;

    public record LockAndMarkProcessingRow(
        int id,
        @NonNull String filename,
        int retryCount
    ) {}

    public List<LockAndMarkProcessingRow> lockAndMarkProcessing(
        int limit
    ) throws SQLException {
        var stmt = conn.prepareStatement(lockAndMarkProcessing);
        stmt.setInt(1, limit);

        var results = stmt.executeQuery();
        var retList = new ArrayList<LockAndMarkProcessingRow>();
        while (results.next()) {
            var ret = new LockAndMarkProcessingRow(
                results.getInt(1),
                results.getString(2),
                results.getInt(3)
            );
            retList.add(ret);
        }

        return retList;
    }

    private static final String lockNextJobs = """
        -- name: LockNextJobs :many
        SELECT id, filename, retry_count
        FROM video_jobs
        WHERE status = 'PENDING'
        ORDER BY created_at
            LIMIT ?
        FOR UPDATE SKIP LOCKED
        """;

    public record LockNextJobsRow(
        int id,
        @NonNull String filename,
        int retryCount
    ) {}

    public List<LockNextJobsRow> lockNextJobs(
        int limit,
        int maxRetry) throws SQLException {
        var stmt = conn.prepareStatement(lockNextJobs);
        stmt.setInt(1, limit);

        var results = stmt.executeQuery();
        var retList = new ArrayList<LockNextJobsRow>();
        while (results.next()) {
            var ret = new LockNextJobsRow(
                results.getInt(1),
                results.getString(2),
                results.getInt(3)
            );
            retList.add(ret);
        }

        return retList;
    }

    private static final String markDone = """
        -- name: MarkDone :exec
        UPDATE video_jobs
        SET status = 'DONE',
            updated_at = now()
        WHERE id = ?
        """;

    public void markDone(
        int id
    ) throws SQLException {
        var stmt = conn.prepareStatement(markDone);
        stmt.setInt(1, id);

        stmt.execute();
    }

    private static final String markFailed = """
        -- name: MarkFailed :exec
        UPDATE video_jobs
        SET status = 'FAILED',
            updated_at = now()
        WHERE id = ?
        """;

    public void markFailed(
        int id
    ) throws SQLException {
        var stmt = conn.prepareStatement(markFailed);
        stmt.setInt(1, id);

        stmt.execute();
    }

    private static final String markProcessing = """
        -- name: MarkProcessing :exec
        UPDATE video_jobs
        SET status = 'PROCESSING',
            updated_at = now()
        WHERE id = ?
        """;

    public void markProcessing(
        int id
    ) throws SQLException {
        var stmt = conn.prepareStatement(markProcessing);
        stmt.setInt(1, id);

        stmt.execute();
    }

    private static final String markRetry = """
        -- name: MarkRetry :exec
        UPDATE video_jobs
        SET retry_count = retry_count + 1,
            next_retry_at = now() + (?::int * interval '1 second'),
            status = 'PENDING',
            updated_at = now()
        WHERE id = ?
        """;

    public void markRetry(
        int column1,
        int id
    ) throws SQLException {
        var stmt = conn.prepareStatement(markRetry);
        stmt.setInt(1, column1);
        stmt.setInt(2, id);

        stmt.execute();
    }

    private static final String resetStuckJobs = """
        -- name: ResetStuckJobs :exec
        UPDATE video_jobs
        SET status = 'PENDING',
            updated_at = now()
        WHERE status = 'PROCESSING'
          AND updated_at < now() - interval '10 minutes'
        """;

    public void resetStuckJobs() throws SQLException {
        var stmt = conn.prepareStatement(resetStuckJobs);

        stmt.execute();
    }

    private static final String upsertVideoJob = """
        -- name: UpsertVideoJob :exec
        INSERT INTO video_jobs (filename, status)
        VALUES (?, ?)
            ON CONFLICT (filename)
        DO UPDATE SET
            status = EXCLUDED.status,
                   updated_at = now()
        """;

    public void upsertVideoJob(
        @NonNull String filename,
        @NonNull String status
    ) throws SQLException {
        var stmt = conn.prepareStatement(upsertVideoJob);
        stmt.setString(1, filename);
        stmt.setString(2, status);

        stmt.execute();
    }
}
